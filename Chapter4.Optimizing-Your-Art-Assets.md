# Chapter 4 资源优化
本章主要讲以下几种资源的优化方案

*   音频文件
*   贴图文件
*   网格和动画
*   AssetBundles 和 resources

# 1. [音频](https://so.csdn.net/so/search?q=%E9%9F%B3%E9%A2%91\&spm=1001.2101.3001.7020)

## 1.1 音频导入设置

![在这里插入图片描述](https://img-blog.csdnimg.cn/77cd386da22446468d4b79ccb4bba54b.png "在这里插入图片描述")

## 1.2 加载音频设置

*   Preload Audio

    *   决定是否在场景初始化的时候自动加载
*   Data Load In Background

    *   是否在加载时阻塞主线。（是同步加载还是异步加载）
    *   此情况下，如果没有使用AudioClip.LoadAudioData() 提前加载，可能导致播放延迟、不同步的情况。
*   Load Type

    *   决定加载什么样的数据进入内存，和一次拉取多少数据。
    *   Decompress On Load:

        *   加载时解压并加入内存，牺牲加载时间，但是播放时工作量很小。
        *   这种模式，一般在场景加载时加载音频，避免运行时出现卡顿。
        *   适合大多数情况
    *   Compressed In Memory

        *   加载时直接拷贝文件进内存，不解压。只有播放时才解压。
        *   节省加载时间和内存消耗，播放时CPU压力加大。
        *   最适合频繁使用的大型音频文件，或者内存出现瓶颈的情况。
    *   Streaming

        *   运行时加载、解码、播放。
        *   内存占用最小，CPU消耗最大。
        *   适用于单一，不更换，持续性的播放，例如：背景音乐和环境音效。

## 1.3 压缩格式和质量

| 格式         | 无损  | 大小   | 质量   | 用途                            |
| ---------- | --- | ---- | ---- | ----------------------------- |
| PCM        | YES | 大    | 好    | 极短的要求高清晰度的音效                  |
| ADPCM      | NO  | 非常小  | 差    | 大量混乱的短音效果可用，例如爆炸、冲击等          |
| Cpmpressed | NO  | 小/普通 | 平台差异 | CPU 消耗高于前两种，大多数情况都可以用，可以自定义质量 |

## 1.4 音频性能增强

*   最小化活动音源数量

    *   使用音频池方式管理最大同时播放的音频数量
*   为3D声音启用强制为单声道

    *   立体声音文件上启用Force to Mono，可降低50%空间。
*   重新采样到低频

    *   需要测试效果，再可以容忍的音质下选择低频采样
*   通过混音器应用过滤效果以减少重复

    *   将多个音频进行混音后，使用过滤器（FilterEffect）播放，这样节省磁盘空间。
    *   但是每个过滤器都会消耗一定的CPU和内存，大量使用会有性能上严重后果。
    *   最好的办法是利用Unity的音频混音器实用程序，生成通用的过滤效果模板，以最小化内存开销。官方教程：<https://learn.unity.com/tutorial/audio-mixing#>
*   考虑用于背景音乐的音频模块（audio module）文件

    *   Unity支持的扩展名有：.it, .s3m, .xm, and .mod. 无损且内存占用小

# 2. 图片纹理

## 2.1 纹理压缩格式

*   一般按平台和需求使用合理的压缩格式，这里给出一位朋友的具体压缩试验和策略推荐（安卓和iOS）<http://www.u3d8.com/?p=2490>
*   根据2021年国内的调查数据，不支持ASTC格式只有2%的机器了。所以完全可以考虑移动平台双端使用ASTC格式。数据来源：[知乎](https://zhuanlan.zhihu.com/p/366436672)

## 2.2 纹理性能增强

### 2.2.1 减小纹理文件大小

比如手机分辨率是1080P，那么少用2048\*2048的贴图。

### 2.2.2 谨慎使用Mip Map

*   注意 Generate Mip Maps选项是默认开启的，开启后打入包的纹理会比原本的大33%。
*   在纹理离摄像机镜头距离基本固定的情况下，尽量关闭Mip Maps

### 2.2.3 从外部管理分辨率的降低

*   Unity允许直接使用.PSD 和 .TIFF 文件。使用这些文件时Unity会自动生成引擎可使用的图片文件并压缩。这确实方便了美术人员，因为只维护一个副本就行了。
*   但是Unity毕竟不是专业图形软件，在生成过程中，有可能产生失真

### 2.2.4 调整Anisotropic Filtering 级别 （抗锯齿）

*   这个消耗蛮大，谨慎使用

### 2.2.5 考虑使用图集

*   使用图集可以有效降低2D和UI产生的Draw Call，同时也可以用在一些动态合批的对象上。
*   骨骼动画（SkinnedMeshRenderer）的多个角色的纹理合在一个图集中是不能降低DrawCall的。
*   如果在Draw Call不是性能瓶颈的情况下，使用图集会增加磁盘和内存占用，反而对性能不友好。

### 2.2.6 调整非方形纹理的压缩率

*   尽量使用 正方形、2的n次幂 分辨率的纹理图片
*   这样的格式对GPU友好，采样效率高。

### 2.2.7 Sparse textures

*   Unity提供处理超大图片的一种方式。将超大图片进行分割再加载，只有摄像机看到的部分贴图进入内存。
*   这个移动端基本不使用，有兴趣的同学可以自行研究。

### 2.2.8 程序化材质

*   也称Substances
*   在初始化期间，通过自定义数学公式混合小型高质量纹理样本。以额外内存和CPU的代价，生成纹理。从而大量的减少纹理带来的磁盘占用。
*   想优化移动端包体大小者可考虑使用。
*   [官方插件下载和文档](https://www.substance3d.com/integrations/substance-in-unity)

### 2.2.9 Asynchronous texture uploading

*   这个功能Unity默认开启
*   可以让纹理数据异步上传到RAM中，节省主线程中的CPU大量时间
*   但是如果纹理开启了Read/Write Enable后，此功能无效，改为同步上传
*   Resources.Load() 和 LoadImage(byte\[]) 加载纹理，无法使用此功能

# 3. [网格](https://so.csdn.net/so/search?q=%E7%BD%91%E6%A0%BC\&spm=1001.2101.3001.7020)和动画文件

## 3.1 减少多边形数量

## 3.2 调整网格压缩

*   网格的4种压缩格式 Off, Low, Medium, High. 直接影响网格数据的精度(顶点位置、法线、颜色等)
*   Player/Other Setting 中的两个导入设置：

    *   Vertex Compression: 可以选择想优化的数据类型，但是这是个全局设置，并不好用。
    *   Optimize Mesh Data: 把模型使用的材质球所不需要的数据在Unity构建时忽略掉。（如果材质球运行中更换了，可能出现不期望的情况）
    *   开启这两个属性可以减少磁盘占用，但是会有额外的解压数据时间。

## 3.3 恰当的使用Read-Write Enable

*   开启时，内存消耗会增加，因为Unity会保存原始副本在内存中，关闭则不会。
*   如果网格经常在运行时以不同比例出现（非等比缩放）时，开启是明智的。因为关闭后，每次都要重新加载网格进入内存，然后复制副本，再丢弃原始网格数据。

## 3.4 考虑烘培动画

*   简单、顶点数少的蒙皮动画可以烘培后再使用。一般是动画软件执行烘培过程。
*   这样可以节省空间和CPU

## 3.5 合并网格

*   一些碎物体，又没有相对移动的。可以合并了再使用，已减少draw call 和顶点数。
*   Asset Store中又不少此类插件

